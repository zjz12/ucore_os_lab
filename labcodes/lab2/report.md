## [练习0]填写已有实验

## [练习1]实现first-fit连续物理内存分配算法
>
首先实验要求更改default_pmm.c中的default_init,default_init_memmap,default_alloc_pages,default_free_pages四个函数，在default_pmm.c文件中找到这些函数，根据提示进行code;
（1）default_init：保留这这个函数的实现;
（2）default_init_memmap：需设置从base开始的每个Page的SetPageProperty(p)，并将其加到空块链表的链首，最后base就不用再加了;
（3）default_alloc_pages：这里需要改变的是在找到合适的可以alloc的page之后的处理，当选择的page的大小大于所需的空间大小(n)时，设置相应的标志位，从链表中删除此页表项，计算剩余空间，然后将剩余的页加入到原来的链表中；
(4)default_free_pages：考虑当找到插入的位置之后合并的部分，分三种情况，第一种就是base跟它的后面可以合并，那就将base的后序页表跟base合并之后删除base的后序页表，第二种就是base与它的前驱页表可以合并，那就将base的前驱页表合并到base之后删除前驱页表，第三种就是不能合并，那就直接将base加入找寻到的位置。


[练习1] 你的first-fit算法是否有进一步的改进空间?
>
把链表改成游标来实现，可以节省空间和提高效率。


## [练习2]实现寻找虚拟地址对应的页表项
>
首先是要在一级页表也就是页表目录项当中查找需要的二级页表，如果二级页表不存在我们就尝试分配物理内存给这个项，如果不成功就return null，如果可以创建就设置标志，之后对页表项进行清零，然后直接计算地址即可。

 
[练习2.1] 请描述页目录项(Pag Director Entry)和页表(Page Table Entry)中每个组成部分的含义和以及对ucore而言的潜在用处。
>
PDX:二级页表在页目录项当中的index，用来作为索引查询二级页表
PDE_ADDR：一个页表项在页目录表当中记录的位置
PTE_P：判定这个页表项是否存在，用于判断构建的页表是否合法
PTE_W：页表项是否可以写
PTE_U：页表的用户权限
PTE_PWT：判定这个页表在构建TLB的时候是否支持拖后写
PTE_PCD：判定这个页表是不是不支持cache
PTE_D：判定这个页是不是脏页
PTE_A：判定这个也是不是可以被接受
PTE_PS：知道这个页的大小，size对于后序页表操作有很大用处。
PTE_MBZ:必须是0的bits有多少位
PTE_AVAIL：是否对于用户的应用程序可用


[练习2.2] 如果ucore执行过程中访问内存,出现了页访问异常,请问硬件要做哪些事情?
>
出现页访问异常后，会进入异常处理程序，硬件需要从硬盘中读取相应的页表到内存中去，然后继续访问；在异常处理过程中，硬件需要保存现场，维护堆栈，对相应寄存器进行处理。


## [练习3]释放某虚地址所在的页并取消对应二级页表项的映射
>
首先判断这个要移除的页是否存在，如果存在进行下一步的操作，找到这个页的映射项，减少这个页被引用的次数，减一即可，如果此时这个页的引用次数变成0，我们就释放这个页，相应的我们要对于tlb进行修改。

[练习3.1]数据结构Page的全局变量(其实是一个数组)的每一项与页表中的页目录项和页表项有无对应关系?如果有,其对应关系是啥?
>
有对应关系，在分配page和释放page时都和页目录项、页表项有关。


[练习3.2]如果希望虚拟地址与物理地址相等,则需要如何修改lab2,完成此事?鼓励通过编程来具体完成这个问题
>

## 与参考答案除了个别细节处有所不同以外，大致流程基本相同。很多地方参考答案给了我很多启示。

## 本实验重要的知识点以及与对应的OS原理中的知识点
最先匹配算法;虚拟地址到物理地址的映射;多级页表的管理。

## 列出你认为OS原理中很重要,但在实验中没有对应上的知识点
最佳匹配，最差匹配，伙伴系统等。
